<p>One of the problems with your example is that you cannot use <code>queryset.count()</code> as a subquery, because <code>.count()</code> tries to evaluate the queryset and return the count.</p>
<p>So one may think that the right approach would be to use <code>Count()</code> instead. Maybe something like this:</p>
<pre><code>Post.objects.annotate(
    count=Count(Tag.objects.filter(post=OuterRef('pk')))
)
</code></pre>
<p>This won't work for two reasons:</p>
<ol>
<li><p>The <code>Tag</code> queryset selects all <code>Tag</code> fields, while <code>Count</code> can only count on one field. Thus: <code>Tag.objects.filter(post=OuterRef('pk')).only('pk')</code> is needed (to select counting on <code>tag.pk</code>).</p>
</li>
<li><p><code>Count</code> itself is not a <code>Subquery</code> class, <code>Count</code> is an <code>Aggregate</code>. So the expression generated by <code>Count</code> is not recognized as a <code>Subquery</code> (<code>OuterRef</code> requires subquery), we can fix that by using <code>Subquery</code>.</p>
</li>
</ol>
<p>Applying fixes for 1) and 2) would produce:</p>
<pre><code>Post.objects.annotate(
    count=Count(Subquery(Tag.objects.filter(post=OuterRef('pk')).only('pk')))
)
</code></pre>
<p><strong>However</strong>
if you inspect the query being produced:</p>
<pre><code>SELECT 
    &quot;tests_post&quot;.&quot;id&quot;,
    &quot;tests_post&quot;.&quot;title&quot;,
    COUNT((SELECT U0.&quot;id&quot; 
            FROM &quot;tests_tag&quot; U0 
            INNER JOIN &quot;tests_post_tags&quot; U1 ON (U0.&quot;id&quot; = U1.&quot;tag_id&quot;) 
            WHERE U1.&quot;post_id&quot; = (&quot;tests_post&quot;.&quot;id&quot;))
    ) AS &quot;count&quot; 
FROM &quot;tests_post&quot; 
GROUP BY 
    &quot;tests_post&quot;.&quot;id&quot;,
    &quot;tests_post&quot;.&quot;title&quot;
</code></pre>
<p>you will notice a <code>GROUP BY</code> clause. This is because <code>COUNT</code> is an aggregate function. Right now it does not affect the result, but in some other cases it may. That's why the <a href="https://docs.djangoproject.com/en/1.11/ref/models/expressions/#using-aggregates-within-a-subquery-expression" rel="noreferrer">docs</a> suggest a different approach, where the aggregation is moved into the <code>subquery</code> via a specific combination of <code>values</code> + <code>annotate</code> + <code>values</code> :</p>
<pre><code>Post.objects.annotate(
    count=Subquery(
        Tag.objects
            .filter(post=OuterRef('pk'))
            # The first .values call defines our GROUP BY clause
            # Its important to have a filtration on every field defined here
            # Otherwise you will have more than one group per row!!!
            # This will lead to subqueries to return more than one row!
            # But they are not allowed to do that!
            # In our example we group only by post
            # and we filter by post via OuterRef
            .values('post')
            # Here we say: count how many rows we have per group 
            .annotate(count=Count('pk'))
            # Here we say: return only the count
            .values('count')
    )
)
</code></pre>
<p>Finally this will produce:</p>
<pre><code>SELECT 
    &quot;tests_post&quot;.&quot;id&quot;,
    &quot;tests_post&quot;.&quot;title&quot;,
    (SELECT COUNT(U0.&quot;id&quot;) AS &quot;count&quot; 
            FROM &quot;tests_tag&quot; U0 
            INNER JOIN &quot;tests_post_tags&quot; U1 ON (U0.&quot;id&quot; = U1.&quot;tag_id&quot;) 
            WHERE U1.&quot;post_id&quot; = (&quot;tests_post&quot;.&quot;id&quot;) 
            GROUP BY U1.&quot;post_id&quot;
    ) AS &quot;count&quot; 
FROM &quot;tests_post&quot;
</code></pre>
