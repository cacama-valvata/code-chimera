<p>Short answer:</p>
<p>Store the center of the source image rectangle and update the center of the rotated image rectangle after the rotation, by the stored center position and return a tuple of the rotated image and the rectangle:</p>
<pre class="lang-py prettyprint-override"><code>def rot_center(image, angle):
    
    center = image.get_rect().center
    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = center)

    return rotated_image, new_rect
</code></pre>
<p>Or write a function which rotates and <code>.blit</code> the image:</p>
<pre class="lang-py prettyprint-override"><code>def blitRotateCenter(surf, image, topleft, angle):

    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = image.get_rect(topleft = topleft).center)

    surf.blit(rotated_image, new_rect.topleft)
</code></pre>
<hr />
<p>Long answer:</p>
<p>For the following examples and explanation I'll use a simple image generated by a rendered text:</p>
<pre class="lang-py prettyprint-override"><code>font = pygame.font.SysFont('Times New Roman', 50)
text = font.render('image', False, (255, 255, 0))
image = pygame.Surface((text.get_width()+1, text.get_height()+1))
pygame.draw.rect(image, (0, 0, 255), (1, 1, *text.get_size()))
image.blit(text, (1, 1))
</code></pre>
<p>An image (<a href="https://www.pygame.org/docs/ref/surface.html" rel="nofollow noreferrer"><code>pygame.Surface</code></a>) can be rotated by <a href="https://www.pygame.org/docs/ref/transform.html#pygame.transform.rotate" rel="nofollow noreferrer"><code>pygame.transform.rotate</code></a>.</p>
<p>If that is done progressively in a loop, then the image gets distorted and rapidly increases:</p>
<pre class="lang-py prettyprint-override"><code>while not done:

    # [...]

    image = pygame.transform.rotate(image, 1)
    screen.blit(image, pos)
    pygame.display.flip()
</code></pre>
<p><a href="https://i.sstatic.net/G7jnR.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/G7jnR.gif" alt="" /></a></p>
<p>This is cause, because the bounding rectangle of a rotated image is always greater than the bounding rectangle of the original image (except some rotations by multiples of 90 degrees).<br />
The image gets distort because of the multiply copies. Each rotation generates a small error (inaccuracy). The sum of the errors is growing and the images decays.</p>
<p>That can be fixed by keeping the original image and &quot;blit&quot; an image which was generated by a single rotation operation form the original image.</p>
<pre class="lang-py prettyprint-override"><code>angle = 0
while not done:

    # [...]

    rotated_image = pygame.transform.rotate(image, angle)
    angle += 1

    screen.blit(rotated_image, pos)
    pygame.display.flip()
</code></pre>
<p><a href="https://i.sstatic.net/7GfVA.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/7GfVA.gif" alt="" /></a></p>
<p>Now the image seems to arbitrary change its position, because the size of the image changes by the rotation and origin is always the top left of the bounding rectangle of the image.</p>
<p>This can be compensated by comparing the <a href="https://en.wikipedia.org/wiki/Minimum_bounding_box" rel="nofollow noreferrer">axis aligned bounding box</a> of the image before the rotation and after the rotation.<br />
For the following math <a href="https://www.pygame.org/docs/ref/math.html" rel="nofollow noreferrer"><code>pygame.math.Vector2</code></a> is used. Note in screen coordinates the y points down the screen, but the mathematical y axis points form the bottom to the top. This causes that the y axis has to be &quot;flipped&quot; during calculations</p>
<p>Set up a list with the 4 corner points of the bounding box:</p>
<pre class="lang-py prettyprint-override"><code>w, h = image.get_size()
box = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
</code></pre>
<p>Rotate the vectors to the corner points by <a href="https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.rotate" rel="nofollow noreferrer"><code>pygame.math.Vector2.rotate</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>box_rotate = [p.rotate(angle) for p in box]
</code></pre>
<p>Get the minimum and the maximum of the rotated points:</p>
<pre class="lang-py prettyprint-override"><code>min_box = (min(box_rotate, key=lambda p: p[0])[0], min(box_rotate, key=lambda p: p[1])[1])
max_box = (max(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1])
</code></pre>
<p>Calculate the &quot;compensated&quot; origin of the upper left point of the image by adding the minimum of the rotated box to the position. For the y coordinate <code>max_box[1]</code> is the minimum, because of the &quot;flipping&quot; along the y axis:</p>
<pre><code>origin = (pos[0] + min_box[0], pos[1] - max_box[1])

rotated_image = pygame.transform.rotate(image, angle)
screen.blit(rotated_image, origin)
</code></pre>
<p><a href="https://i.sstatic.net/N0OsV.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/N0OsV.gif" alt="" /></a></p>
<p>It is even possible to define a pivot on the original image. The &quot;translation&quot; of the pivot in relation to the upper left of the image has to be calculated and the &quot;blit&quot; position of the image has to be displaced by the translation.</p>
<p>Define a pivot e.g. in the center of the image:</p>
<pre class="lang-py prettyprint-override"><code>pivot = pygame.math.Vector2(w/2, -h/2)
</code></pre>
<p>Calculate the translation of the rotated pivot:</p>
<pre class="lang-py prettyprint-override"><code>pivot_rotate = pivot.rotate(angle)
pivot_move   = pivot_rotate - pivot
</code></pre>
<p>Finally calculate the origin of the rotated image:</p>
<pre class="lang-py prettyprint-override"><code>origin = (pos[0] + min_box[0] - pivot_move[0], pos[1] - max_box[1] + pivot_move[1])

rotated_image = pygame.transform.rotate(image, angle)
screen.blit(rotated_image, origin)
</code></pre>
<p>In the following example program, the function <code>blitRotate</code> does all the above steps and &quot;blit&quot; a rotated image to a surface. <code>pos</code> is the position of the image. <code>originPos</code> is the point on the image which is placed on <code>pos</code> and the pivot:</p>
<p><a href="https://i.sstatic.net/diqBY.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/diqBY.gif" alt="" /></a></p>
<pre class="lang-py prettyprint-override"><code>import pygame
import pygame.font

pygame.init()
size = (400,400)
screen = pygame.display.set_mode(size)
clock = pygame.time.Clock()

def blitRotate(surf, image, pos, originPos, angle):

    # calcaulate the axis aligned bounding box of the rotated image
    w, h       = image.get_size()
    box        = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
    box_rotate = [p.rotate(angle) for p in box]
    min_box    = (min(box_rotate, key=lambda p: p[0])[0], min(box_rotate, key=lambda p: p[1])[1])
    max_box    = (max(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1])

    # calculate the translation of the pivot 
    pivot        = pygame.math.Vector2(originPos[0], -originPos[1])
    pivot_rotate = pivot.rotate(angle)
    pivot_move   = pivot_rotate - pivot

    # calculate the upper left origin of the rotated image
    origin = (pos[0] - originPos[0] + min_box[0] - pivot_move[0], pos[1] - originPos[1] - max_box[1] + pivot_move[1])

    # get a rotated image
    rotated_image = pygame.transform.rotate(image, angle)

    # rotate and blit the image
    surf.blit(rotated_image, origin)

    # draw rectangle around the image
    pygame.draw.rect (surf, (255, 0, 0), (*origin, *rotated_image.get_size()),2)

font = pygame.font.SysFont('Times New Roman', 50)
text = font.render('image', False, (255, 255, 0))
image = pygame.Surface((text.get_width()+1, text.get_height()+1))
pygame.draw.rect(image, (0, 0, 255), (1, 1, *text.get_size()))
image.blit(text, (1, 1))
w, h = image.get_size()

angle = 0
done = False
while not done:
    clock.tick(60)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            done = True
        elif event.type == pygame.KEYDOWN:
            if event.key==pygame.K_ESCAPE:
                done = True

    pos = (screen.get_width()/2, screen.get_height()/2)
    pos = (200, 200)

    screen.fill(0)
    blitRotate(screen, image, pos, (w/2, h/2), angle)
    angle += 1

    pygame.draw.line(screen, (0, 255, 0), (pos[0]-20, pos[1]), (pos[0]+20, pos[1]), 3)
    pygame.draw.line(screen, (0, 255, 0), (pos[0], pos[1]-20), (pos[0], pos[1]+20), 3)
    pygame.draw.circle(screen, (0, 255, 0), pos, 7, 0)

    pygame.display.flip()

pygame.quit()
</code></pre>
